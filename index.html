<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Square Words</title>
    <link rel="icon" type="image/svg+xml" href="logo.svg">
    <style>
        .header {
            display: flex;
            align-items: center;
            margin: 0 auto;
            max-width: 300px;
        }
        .filter-container {
            display: flex;
            max-width: 300px;
            margin: 0 auto;
            gap: 10px;
            align-items: center;
        }
        #filter {
            flex: 1;
            min-width: 0;
            padding: 8px;
            box-sizing: border-box;
        }
        #iFilter {
            width: 80px;
            padding: 8px;
            box-sizing: border-box;
        }
        #count {
            margin-bottom: 10px;
            color: #666;
        }
        #words-container {
            position: relative;
            height: calc(100vh - 160px);
            overflow-y: auto;
            background: white;
        }
        .word-pair {
            max-width: 300px;
            margin: 0 auto;
            border: 1px solid #ddd;
            position: absolute;
            left: 0;
            right: 0;
        }
        .word-pair-content {
            padding: 10px;
        }
        .w1-prefix { color: #009689; }
        .w1-suffix { color: #E17100; }
        .w2-prefix { color: #E17100; }
        .w2-suffix { color: #155DFC; }
        .loading { 
            padding: 20px;
            margin: 0 auto;
            max-width: 300px;
        }
        p { margin: 0; font-family: monospace; }
        .title { margin: 0; }
        body { padding: 0 10px; margin: 0; }
        #loadAllBtn { cursor: pointer; }
        .header-content { margin: 10px; }
        .count-container { 
            margin: 10px auto; 
            max-width: 300px; 
        }
        .count-container > span { margin: 20px 0; }
    </style>
    <script>
        !function(t,e){var o,n,p,r;e.__SV||(window.posthog && window.posthog.__loaded)||(window.posthog=e,e._i=[],e.init=function(i,s,a){function g(t,e){var o=e.split(".");2==o.length&&(t=t[o[0]],e=o[1]),t[e]=function(){t.push([e].concat(Array.prototype.slice.call(arguments,0)))}}(p=t.createElement("script")).type="text/javascript",p.crossOrigin="anonymous",p.async=!0,p.src=s.api_host.replace(".i.posthog.com","-assets.i.posthog.com")+"/static/array.js",(r=t.getElementsByTagName("script")[0]).parentNode.insertBefore(p,r);var u=e;for(void 0!==a?u=e[a]=[]:a="posthog",u.people=u.people||[],u.toString=function(t){var e="posthog";return"posthog"!==a&&(e+="."+a),t||(e+=" (stub)"),e},u.people.toString=function(){return u.toString(1)+".people (stub)"},o="init fi Cr Or ci Tr Ir capture Mi calculateEventProperties Ar register register_once register_for_session unregister unregister_for_session Nr getFeatureFlag getFeatureFlagPayload isFeatureEnabled reloadFeatureFlags updateEarlyAccessFeatureEnrollment getEarlyAccessFeatures on onFeatureFlags onSurveysLoaded onSessionId getSurveys getActiveMatchingSurveys renderSurvey displaySurvey canRenderSurvey canRenderSurveyAsync identify setPersonProperties group resetGroups setPersonPropertiesForFlags resetPersonPropertiesForFlags setGroupPropertiesForFlags resetGroupPropertiesForFlags reset get_distinct_id getGroups get_session_id get_session_replay_url alias set_config startSessionRecording stopSessionRecording sessionRecordingStarted captureException loadToolbar get_property getSessionProperty jr Mr createPersonProfile Lr kr Ur opt_in_capturing opt_out_capturing has_opted_in_capturing has_opted_out_capturing get_explicit_consent_status is_capturing clear_opt_in_out_capturing Fr debug M Dr getPageViewId captureTraceFeedback captureTraceMetric Sr".split(" "),n=0;n<o.length;n++)g(u,o[n]);e._i.push([i,s,a])},e.__SV=1)}(document,window.posthog||[]);
        posthog.init('phc_hgnRo2d1zsZ98tiuQjtTd0kWfNxuAmIccUmN0QKQSY1', {
            api_host: 'https://us.i.posthog.com',
            defaults: '2025-05-24',
            person_profiles: 'always', // or 'always' to create profiles for anonymous users as well
        })
    </script>
</head>
<body>
    <div class="header">
        <img height="60px" src="logo.svg" alt="Square Words" class="logo">
        <div class="header-content">
            <h1 class="title">Square Words</h1>
            <a href="https://github.com/xuchef/square-words" target="_blank">github.com/xuchef/square-words</a>
        </div>
    </div>
    <div class="filter-container">
        <input type="text" id="filter" placeholder="regex filter" autocomplete="off">
        <input type="number" id="iFilter" placeholder="prefix" autocomplete="off" min="2">
    </div>
    <div class="count-container">
        <span id="count"></span>
        <button id="loadAllBtn">load all</button>
    </div>
    <div id="words-container">
        <div class="loading">Loading...</div>
    </div>

    <script>
        // Claude cooked this up
        let allPairs = [];
        let filteredPairs = [];
        
        // Virtual scrolling parameters
        const ITEM_HEIGHT = 62; // Height of each word-pair element
        const BUFFER = 5; // Extra items to render above/below viewport
        
        async function loadWords() {
            try {
                const response = await fetch('square_words.json');
                const data = await response.json();
                allPairs = data;
                filteredPairs = allPairs;
                renderVirtual();
            } catch (error) {
                document.getElementById('words-container').innerHTML = 
                    '<div class="loading">Error loading words: ' + error.message + '</div>';
            }
        }
        
        async function loadAllWords() {
            const btn = document.getElementById('loadAllBtn');
            btn.disabled = true;
            btn.textContent = 'loading...';
            
            try {
                const response = await fetch('square_words.json.gz');
                const arrayBuffer = await response.arrayBuffer();
                
                // Decompress gzip data
                const decompressedStream = new DecompressionStream('gzip');
                const blob = new Blob([arrayBuffer]);
                const stream = blob.stream().pipeThrough(decompressedStream);
                const decompressedBlob = await new Response(stream).blob();
                const text = await decompressedBlob.text();
                
                const data = JSON.parse(text);
                allPairs = data;
                filteredPairs = allPairs;
                renderVirtual();
                
                btn.style.display = 'none';
            } catch (error) {
                document.getElementById('words-container').innerHTML = 
                    '<div class="loading">Error loading words: ' + error.message + '</div>';
                btn.disabled = false;
                btn.textContent = 'load all';
            }
        }
        
        function renderVirtual() {
            const container = document.getElementById('words-container');
            const count = document.getElementById('count');
            const pairs = filteredPairs;
            
            count.textContent = `Showing ${pairs.length.toLocaleString()} square words`;
            
            if (pairs.length === 0) {
                container.innerHTML = '<div class="loading">No matches found</div>';
                return;
            }
            
            // Set container height to accommodate all items
            const totalHeight = pairs.length * ITEM_HEIGHT;
            container.innerHTML = `<div style="height: ${totalHeight}px; position: relative;"></div>`;
            const wrapper = container.firstChild;
            
            // Scroll handler for virtual scrolling
            let ticking = false;
            container.addEventListener('scroll', () => {
                if (!ticking) {
                    window.requestAnimationFrame(() => {
                        updateVisibleItems(wrapper, pairs);
                        ticking = false;
                    });
                    ticking = true;
                }
            });
            
            // Initial render
            updateVisibleItems(wrapper, pairs);
        }
        
        function updateVisibleItems(wrapper, pairs) {
            const container = document.getElementById('words-container');
            const scrollTop = container.scrollTop;
            const containerHeight = container.clientHeight;
            
            // Calculate visible range
            const startIndex = Math.max(0, Math.floor(scrollTop / ITEM_HEIGHT) - BUFFER);
            const endIndex = Math.min(
                pairs.length,
                Math.ceil((scrollTop + containerHeight) / ITEM_HEIGHT) + BUFFER
            );
            
            // Create fragment with visible items
            const fragment = document.createDocumentFragment();
            
            for (let i = startIndex; i < endIndex; i++) {
                const [w1, w2, splitIdx] = pairs[i];
                const prefix1 = w1.substring(0, splitIdx);
                const suffix1 = w1.substring(splitIdx);
                const prefix2 = w2.substring(0, splitIdx);
                const suffix2 = w2.substring(splitIdx);
                
                const div = document.createElement('div');
                div.className = 'word-pair';
                div.style.top = `${i * ITEM_HEIGHT}px`;
                div.innerHTML = `
                    <div class="word-pair-content">
                        <p><span class="w1-prefix">${prefix1}</span><span class="w1-suffix">${suffix1}</span></p>
                        <p><span class="w2-prefix">${prefix2}</span><span class="w2-suffix">${suffix2}</span></p>
                    </div>
                `;
                fragment.appendChild(div);
            }
            
            // Replace all children at once
            wrapper.textContent = '';
            wrapper.appendChild(fragment);
        }
        
        function filterWords(searchTerm, iValue) {
            const term = searchTerm.toLowerCase();
            const i = iValue ? parseInt(iValue) : null;
            
            let regex = null;
            if (term) {
                try {
                    regex = new RegExp(term, 'i');
                } catch (e) {
                    // Invalid regex, fall back to literal string matching
                    regex = null;
                }
            }
            
            filteredPairs = allPairs.filter(([w1, w2, splitIdx]) => {
                let matchesTerm = true;
                if (regex) {
                    matchesTerm = regex.test(w1) || regex.test(w2);
                } else if (term) {
                    matchesTerm = w1.includes(term) || w2.includes(term);
                }
                const matchesI = i === null || splitIdx === i;
                return matchesTerm && matchesI;
            });
            
            renderVirtual();
        }
        
        document.getElementById('filter').addEventListener('keypress', (e) => {
            if (e.key === 'Enter') {
                const iValue = document.getElementById('iFilter').value;
                filterWords(e.target.value, iValue);
            }
        });

        document.getElementById('filter').addEventListener('input', (e) => {
            if (e.target.value === '') {
                const iValue = document.getElementById('iFilter').value;
                filterWords(e.target.value, iValue);
            }
        });
        
        document.getElementById('iFilter').addEventListener('input', (e) => {
            const searchTerm = document.getElementById('filter').value;
            filterWords(searchTerm, e.target.value);
        });
        
        document.getElementById('loadAllBtn').addEventListener('click', loadAllWords);
        
        loadWords();
    </script>
</body>
</html>
